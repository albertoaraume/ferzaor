{"version":3,"file":"theia-sticky-sidebar.umd.js","sources":["../lib/theia-sticky-sidebar.ts"],"sourcesContent":["/*!\n * Theia Sticky Sidebar v2.0.0\n * https://github.com/WeCodePixels/theia-sticky-sidebar\n *\n * Glues your website's sidebars, making them permanently visible while scrolling.\n *\n * Copyright 2013-2025 WeCodePixels and other contributors\n * Released under the MIT license\n */\n\ninterface Options {\n    elements: string | HTMLElement | Array<HTMLElement>,\n    containerSelector: string,\n    additionalMarginTop: number,\n    additionalMarginBottom: number,\n    updateSidebarHeight: boolean,\n    minWidth: number,\n    disableOnResponsiveLayouts: boolean,\n    sidebarBehavior: string,\n    defaultPosition: string,\n    verbose: boolean,\n}\n\ninterface StickySidebar {\n    options: Options,\n    sidebar: HTMLElement,\n    stickySidebar: HTMLElement,\n    container: HTMLElement,\n    onScroll: () => unknown,\n    previousScrollTop: number,\n    fixedScrollTop: number,\n    stickySidebarPaddingTop: number,\n    stickySidebarPaddingBottom: number,\n    marginBottom: number,\n    paddingTop: number,\n    paddingBottom: number,\n    resizeObserver: ResizeObserver,\n}\n\nexport class TheiaStickySidebar {\n    private readonly options: Options;\n    private elements: Array<HTMLElement>;\n    private initialized: boolean = false;\n    private stickySidebars: Array<StickySidebar> = [];\n\n    public constructor(options: Partial<Options>) {\n        const defaults: Options = {\n            elements: '',\n            containerSelector: '',\n            additionalMarginTop: 0,\n            additionalMarginBottom: 0,\n            updateSidebarHeight: true,\n            minWidth: 0,\n            disableOnResponsiveLayouts: true,\n            sidebarBehavior: 'modern',\n            defaultPosition: 'relative',\n            verbose: false,\n        };\n        const finalOptions = {...defaults, ...options};\n\n        // Validate options\n        finalOptions.additionalMarginTop = Math.floor(options.additionalMarginTop || 0);\n        finalOptions.additionalMarginBottom = Math.floor(options.additionalMarginBottom || 0);\n\n        if (finalOptions.elements instanceof HTMLElement) {\n            this.elements = [finalOptions.elements];\n        } else if (finalOptions.elements instanceof Array) {\n            this.elements = finalOptions.elements\n        } else {\n            this.elements = Array.from(document.querySelectorAll(finalOptions.elements));\n        }\n        this.options = finalOptions;\n        this.tryInitOrHookIntoEvents();\n    }\n\n    public unbind = () => {\n        document.removeEventListener('scroll', this.tryDelayedInit);\n        window.removeEventListener('resize', this.tryDelayedInit);\n\n        this.stickySidebars.forEach(o => {\n            document.removeEventListener('scroll', o.onScroll);\n            window.removeEventListener('resize', o.onScroll);\n            o.resizeObserver.disconnect();\n        })\n    };\n\n    // Try doing init, otherwise hook into window.resize and document.scroll and try again then.\n    private tryInitOrHookIntoEvents = () => {\n        const success = this.tryInit();\n\n        if (!success) {\n            if (this.options.verbose) {\n                console.log('TSS: Body width smaller than options.minWidth. Init is delayed.');\n            }\n\n            document.addEventListener('scroll', this.tryDelayedInit);\n            window.addEventListener('resize', this.tryDelayedInit);\n        }\n    }\n\n    private tryDelayedInit = () => {\n        const success = this.tryInit();\n\n        if (success) {\n            document.removeEventListener('scroll', this.tryDelayedInit);\n            window.removeEventListener('resize', this.tryDelayedInit);\n        }\n    }\n\n    // Try doing init if proper conditions are met.\n    private tryInit() {\n        if (this.initialized) {\n            return true;\n        }\n\n        if (document.body.getBoundingClientRect().width < this.options.minWidth) {\n            return false;\n        }\n\n        this.init();\n\n        return true;\n    }\n\n    // Init the sticky sidebar(s).\n    private init() {\n        this.initialized = true;\n\n        // Add CSS\n        const existingStylesheet = document.querySelector('#theia-sticky-sidebar-stylesheet');\n        if (!existingStylesheet) {\n            document.head.insertAdjacentHTML('beforeend', '<style id=\"theia-sticky-sidebar-stylesheet\">.theiaStickySidebar:after {content: \"\"; display: table; clear: both;}</style>');\n        }\n\n        this.elements.forEach(element => {\n            const o: StickySidebar = {} as StickySidebar;\n\n            o.sidebar = element;\n\n            // Save options\n            o.options = this.options || {};\n\n            // Get container\n            o.container = (o.options.containerSelector && document.querySelector(o.options.containerSelector)) as HTMLElement;\n            if (!o.container) {\n                o.container = o.sidebar.parentNode as HTMLElement;\n            }\n\n            // Create sticky sidebar\n            Object.assign(o.sidebar.style, {\n                position: o.options.defaultPosition,\n                overflow: 'visible',\n                boxSizing: 'border-box'\n            });\n\n            // Get the sticky sidebar element. If none has been found, then create one.\n            o.stickySidebar = o.sidebar.querySelector('.theiaStickySidebar') as HTMLElement;\n            if (!o.stickySidebar) {\n                // Remove <script> tags, otherwise they will be run again when added to the stickySidebar.\n                const javaScriptMIMETypes = /(?:text|application)\\/(?:x-)?(?:javascript|ecmascript)/i;\n                Array.from(o.sidebar.querySelectorAll('script')).forEach(script => {\n                    if (script.type.length === 0 || script.type.match(javaScriptMIMETypes)) {\n                        script.remove();\n                    }\n                });\n\n                o.stickySidebar = document.createElement('div');\n                o.stickySidebar.classList.add('theiaStickySidebar');\n                o.stickySidebar.append(...o.sidebar.children);\n                o.sidebar.append(o.stickySidebar);\n            }\n\n            // Get existing top and bottom margins and paddings\n            const computedStyle = getComputedStyle(o.sidebar);\n            o.marginBottom = parseFloat(computedStyle.marginBottom);\n            o.paddingTop = parseFloat(computedStyle.paddingTop);\n            o.paddingBottom = parseFloat(computedStyle.paddingBottom);\n\n            // Add a temporary padding rule to check for collapsable margins.\n            let collapsedTopHeight = getOffset(o.stickySidebar).top;\n            let collapsedBottomHeight = o.stickySidebar.offsetHeight;\n            o.stickySidebar.style.paddingTop = '1px';\n            o.stickySidebar.style.paddingBottom = '1px';\n            collapsedTopHeight -= getOffset(o.stickySidebar).top;\n            collapsedBottomHeight = o.stickySidebar.offsetHeight - collapsedBottomHeight - collapsedTopHeight;\n            if (collapsedTopHeight == 0) {\n                o.stickySidebar.style.paddingTop = '0px';\n                o.stickySidebarPaddingTop = 0;\n            } else {\n                o.stickySidebarPaddingTop = 1;\n            }\n\n            if (collapsedBottomHeight == 0) {\n                o.stickySidebar.style.paddingBottom = '0px';\n                o.stickySidebarPaddingBottom = 0;\n            } else {\n                o.stickySidebarPaddingBottom = 1;\n            }\n\n            // We use this to know whether the user is scrolling up or down.\n            o.previousScrollTop = 0;\n\n            // Scroll top (value) when the sidebar has fixed position.\n            o.fixedScrollTop = 0;\n\n            // Set sidebar to default values.\n            this.resetSidebar(o);\n\n            o.onScroll = () => {\n                // Stop if the sidebar isn't visible.\n                if (!this.isVisible(o.stickySidebar)) {\n                    return;\n                }\n\n                // Stop if the window is too small.\n                if (document.body.getBoundingClientRect().width < o.options.minWidth) {\n                    this.resetSidebar(o);\n                    return;\n                }\n\n                // Stop if the sidebar width is larger than the container width (e.g. the theme is responsive and the sidebar is now below the content)\n                if (o.options.disableOnResponsiveLayouts) {\n                    const sidebarWidth = getComputedStyle(o.sidebar).float === 'none' ? this.getOuterWidth(o.sidebar) : o.sidebar.offsetWidth;\n\n                    if (sidebarWidth + 50 > o.container.getBoundingClientRect().width) {\n                        this.resetSidebar(o);\n                        return;\n                    }\n                }\n\n                const scrollTop = window.scrollY;\n                let position = 'static';\n                const sidebarOffset = getOffset(o.sidebar);\n                let top = 0;\n\n                // If the user has scrolled down enough for the sidebar to be clipped at the top, then we can consider changing its position.\n                if (scrollTop >= sidebarOffset.top + (o.paddingTop - o.options.additionalMarginTop)) {\n                    // The top and bottom offsets, used in various calculations.\n                    const offsetTop = o.paddingTop + this.options.additionalMarginTop;\n                    const offsetBottom = o.paddingBottom + o.marginBottom + this.options.additionalMarginBottom;\n\n                    // All top and bottom positions are relative to the window, not to the parent elemnts.\n                    const containerTop = sidebarOffset.top;\n                    const containerBottom = getOffset(o.container).top + this.getClearedHeight(o.container);\n\n                    // The top and bottom offsets relative to the window screen top (zero) and bottom (window height).\n                    const windowOffsetTop = this.options.additionalMarginTop;\n                    let windowOffsetBottom;\n\n                    const sidebarSmallerThanWindow = (o.stickySidebar.offsetHeight + offsetTop + offsetBottom) < window.innerHeight;\n                    if (sidebarSmallerThanWindow) {\n                        windowOffsetBottom = windowOffsetTop + o.stickySidebar.offsetHeight;\n                    } else {\n                        windowOffsetBottom = window.innerHeight - o.marginBottom - o.paddingBottom - this.options.additionalMarginBottom;\n                    }\n\n                    const staticLimitTop = containerTop - scrollTop + o.paddingTop;\n                    const staticLimitBottom = containerBottom - scrollTop - o.paddingBottom - o.marginBottom;\n\n                    top = getOffset(o.stickySidebar).top - scrollTop;\n                    const scrollTopDiff = o.previousScrollTop - scrollTop;\n\n                    // If the sidebar position is fixed, then it won't move up or down by itself. So, we manually adjust the top coordinate.\n                    if (getComputedStyle(o.stickySidebar).position === 'fixed') {\n                        if (o.options.sidebarBehavior == 'modern') {\n                            top += scrollTopDiff;\n                        }\n                    }\n\n                    if (o.options.sidebarBehavior == 'stick-to-top') {\n                        top = this.options.additionalMarginTop;\n                    }\n\n                    if (o.options.sidebarBehavior == 'stick-to-bottom') {\n                        top = windowOffsetBottom - o.stickySidebar.offsetHeight;\n                    }\n\n                    if (scrollTopDiff > 0) { // If the user is scrolling up.\n                        top = Math.min(top, windowOffsetTop);\n                    } else { // If the user is scrolling down.\n                        top = Math.max(top, windowOffsetBottom - o.stickySidebar.offsetHeight);\n                    }\n\n                    top = Math.max(top, staticLimitTop);\n\n                    top = Math.min(top, staticLimitBottom - o.stickySidebar.offsetHeight);\n\n                    // If the sidebar is the same height as the container, we won't use fixed positioning.\n                    const sidebarSameHeightAsContainer = o.container.getBoundingClientRect().height == o.stickySidebar.offsetHeight;\n\n                    if (!sidebarSameHeightAsContainer && top == windowOffsetTop) {\n                        position = 'fixed';\n                    } else if (!sidebarSameHeightAsContainer && top == windowOffsetBottom - o.stickySidebar.offsetHeight) {\n                        position = 'fixed';\n                    } else if (scrollTop + top - sidebarOffset.top - o.paddingTop <= this.options.additionalMarginTop) {\n                        // Stuck to the top of the page. No special behavior.\n                        position = 'static';\n                    } else {\n                        // Stuck to the bottom of the page.\n                        position = 'absolute';\n                    }\n                }\n\n                /*\n                 * Performance notice: It's OK to set these CSS values at each resize/scroll, even if they don't change.\n                 * It's way slower to first check if the values have changed.\n                 */\n                if (position == 'fixed') {\n                    Object.assign(o.stickySidebar.style, {\n                        position: 'fixed',\n                        width: o.stickySidebar.getBoundingClientRect().width + 'px',\n                        transform: 'translateY(' + top + 'px)',\n                        left: (getOffset(o.sidebar).left + parseFloat(getComputedStyle(o.sidebar).paddingLeft) - window.scrollX) + 'px',\n                        top: '0px'\n                    });\n                } else if (position == 'absolute') {\n                    const css: Partial<CSSStyleDeclaration> = {};\n\n                    if (getComputedStyle(o.stickySidebar).position !== 'absolute') {\n                        css.position = 'absolute';\n                        css.transform = 'translateY(' + (scrollTop + top - sidebarOffset.top - o.stickySidebarPaddingTop - o.stickySidebarPaddingBottom) + 'px)';\n                        css.top = '0px';\n                    }\n\n                    css.width = o.stickySidebar.getBoundingClientRect().width + 'px';\n                    css.left = '';\n\n                    Object.assign(o.stickySidebar.style, css);\n                } else if (position == 'static') {\n                    this.resetSidebar(o);\n                }\n\n                if (position != 'static') {\n                    if (o.options.updateSidebarHeight) {\n                        o.sidebar.style.minHeight = (o.stickySidebar.offsetHeight + getOffset(o.stickySidebar).top - sidebarOffset.top + o.paddingBottom) + 'px';\n                    }\n                }\n\n                o.previousScrollTop = scrollTop;\n            };\n\n            // Initialize the sidebar's position.\n            o.onScroll();\n\n            // Recalculate the sidebar's position on every scroll and resize.\n            document.addEventListener('scroll', o.onScroll);\n            window.addEventListener('resize', o.onScroll);\n\n            // Recalculate the sidebar's position every time the sidebar changes its size.\n            o.resizeObserver = new ResizeObserver(() => {\n                o.onScroll();\n            });\n            o.resizeObserver.observe(o.stickySidebar);\n\n            this.stickySidebars.push(o);\n        });\n    }\n\n    private getOuterWidth(element: HTMLElement): number {\n        const style = getComputedStyle(element);\n\n        return element.getBoundingClientRect().width + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    }\n\n    private isVisible(element: HTMLElement) {\n        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n    }\n\n    // Reset the sidebar to its default state\n    private resetSidebar(s: StickySidebar) {\n        s.fixedScrollTop = 0;\n        s.sidebar.style.minHeight = '1px';\n        Object.assign(s.stickySidebar.style, {\n            'position': 'static',\n            'width': '',\n            'transform': 'none'\n        });\n    }\n\n    // Get the height of a div as if its floated children were cleared. Note that this function fails if the floats are more than one level deep.\n    private getClearedHeight(element: HTMLElement) {\n        let height = element.getBoundingClientRect().height;\n\n        Array.from(element.children).forEach(child => {\n            height = Math.max(height, child.getBoundingClientRect().height);\n        });\n\n        return height;\n    }\n}\n\nexport function getOffset(element: HTMLElement): { top: number, left: number } {\n    const rect = element.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY - document.documentElement.clientTop,\n        left: rect.left + window.scrollX - document.documentElement.clientLeft\n    };\n}\n"],"names":["TheiaStickySidebar","options","__publicField","o","finalOptions","element","javaScriptMIMETypes","script","computedStyle","collapsedTopHeight","getOffset","collapsedBottomHeight","scrollTop","position","sidebarOffset","top","offsetTop","offsetBottom","containerTop","containerBottom","windowOffsetTop","windowOffsetBottom","staticLimitTop","staticLimitBottom","scrollTopDiff","sidebarSameHeightAsContainer","css","style","s","height","child","rect"],"mappings":"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"}