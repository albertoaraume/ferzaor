{"version":3,"file":"theia-sticky-sidebar.es.js","sources":["../lib/theia-sticky-sidebar.ts"],"sourcesContent":["/*!\n * Theia Sticky Sidebar v2.0.0\n * https://github.com/WeCodePixels/theia-sticky-sidebar\n *\n * Glues your website's sidebars, making them permanently visible while scrolling.\n *\n * Copyright 2013-2025 WeCodePixels and other contributors\n * Released under the MIT license\n */\n\ninterface Options {\n    elements: string | HTMLElement | Array<HTMLElement>,\n    containerSelector: string,\n    additionalMarginTop: number,\n    additionalMarginBottom: number,\n    updateSidebarHeight: boolean,\n    minWidth: number,\n    disableOnResponsiveLayouts: boolean,\n    sidebarBehavior: string,\n    defaultPosition: string,\n    verbose: boolean,\n}\n\ninterface StickySidebar {\n    options: Options,\n    sidebar: HTMLElement,\n    stickySidebar: HTMLElement,\n    container: HTMLElement,\n    onScroll: () => unknown,\n    previousScrollTop: number,\n    fixedScrollTop: number,\n    stickySidebarPaddingTop: number,\n    stickySidebarPaddingBottom: number,\n    marginBottom: number,\n    paddingTop: number,\n    paddingBottom: number,\n    resizeObserver: ResizeObserver,\n}\n\nexport class TheiaStickySidebar {\n    private readonly options: Options;\n    private elements: Array<HTMLElement>;\n    private initialized: boolean = false;\n    private stickySidebars: Array<StickySidebar> = [];\n\n    public constructor(options: Partial<Options>) {\n        const defaults: Options = {\n            elements: '',\n            containerSelector: '',\n            additionalMarginTop: 0,\n            additionalMarginBottom: 0,\n            updateSidebarHeight: true,\n            minWidth: 0,\n            disableOnResponsiveLayouts: true,\n            sidebarBehavior: 'modern',\n            defaultPosition: 'relative',\n            verbose: false,\n        };\n        const finalOptions = {...defaults, ...options};\n\n        // Validate options\n        finalOptions.additionalMarginTop = Math.floor(options.additionalMarginTop || 0);\n        finalOptions.additionalMarginBottom = Math.floor(options.additionalMarginBottom || 0);\n\n        if (finalOptions.elements instanceof HTMLElement) {\n            this.elements = [finalOptions.elements];\n        } else if (finalOptions.elements instanceof Array) {\n            this.elements = finalOptions.elements\n        } else {\n            this.elements = Array.from(document.querySelectorAll(finalOptions.elements));\n        }\n        this.options = finalOptions;\n        this.tryInitOrHookIntoEvents();\n    }\n\n    public unbind = () => {\n        document.removeEventListener('scroll', this.tryDelayedInit);\n        window.removeEventListener('resize', this.tryDelayedInit);\n\n        this.stickySidebars.forEach(o => {\n            document.removeEventListener('scroll', o.onScroll);\n            window.removeEventListener('resize', o.onScroll);\n            o.resizeObserver.disconnect();\n        })\n    };\n\n    // Try doing init, otherwise hook into window.resize and document.scroll and try again then.\n    private tryInitOrHookIntoEvents = () => {\n        const success = this.tryInit();\n\n        if (!success) {\n            if (this.options.verbose) {\n                console.log('TSS: Body width smaller than options.minWidth. Init is delayed.');\n            }\n\n            document.addEventListener('scroll', this.tryDelayedInit);\n            window.addEventListener('resize', this.tryDelayedInit);\n        }\n    }\n\n    private tryDelayedInit = () => {\n        const success = this.tryInit();\n\n        if (success) {\n            document.removeEventListener('scroll', this.tryDelayedInit);\n            window.removeEventListener('resize', this.tryDelayedInit);\n        }\n    }\n\n    // Try doing init if proper conditions are met.\n    private tryInit() {\n        if (this.initialized) {\n            return true;\n        }\n\n        if (document.body.getBoundingClientRect().width < this.options.minWidth) {\n            return false;\n        }\n\n        this.init();\n\n        return true;\n    }\n\n    // Init the sticky sidebar(s).\n    private init() {\n        this.initialized = true;\n\n        // Add CSS\n        const existingStylesheet = document.querySelector('#theia-sticky-sidebar-stylesheet');\n        if (!existingStylesheet) {\n            document.head.insertAdjacentHTML('beforeend', '<style id=\"theia-sticky-sidebar-stylesheet\">.theiaStickySidebar:after {content: \"\"; display: table; clear: both;}</style>');\n        }\n\n        this.elements.forEach(element => {\n            const o: StickySidebar = {} as StickySidebar;\n\n            o.sidebar = element;\n\n            // Save options\n            o.options = this.options || {};\n\n            // Get container\n            o.container = (o.options.containerSelector && document.querySelector(o.options.containerSelector)) as HTMLElement;\n            if (!o.container) {\n                o.container = o.sidebar.parentNode as HTMLElement;\n            }\n\n            // Create sticky sidebar\n            Object.assign(o.sidebar.style, {\n                position: o.options.defaultPosition,\n                overflow: 'visible',\n                boxSizing: 'border-box'\n            });\n\n            // Get the sticky sidebar element. If none has been found, then create one.\n            o.stickySidebar = o.sidebar.querySelector('.theiaStickySidebar') as HTMLElement;\n            if (!o.stickySidebar) {\n                // Remove <script> tags, otherwise they will be run again when added to the stickySidebar.\n                const javaScriptMIMETypes = /(?:text|application)\\/(?:x-)?(?:javascript|ecmascript)/i;\n                Array.from(o.sidebar.querySelectorAll('script')).forEach(script => {\n                    if (script.type.length === 0 || script.type.match(javaScriptMIMETypes)) {\n                        script.remove();\n                    }\n                });\n\n                o.stickySidebar = document.createElement('div');\n                o.stickySidebar.classList.add('theiaStickySidebar');\n                o.stickySidebar.append(...o.sidebar.children);\n                o.sidebar.append(o.stickySidebar);\n            }\n\n            // Get existing top and bottom margins and paddings\n            const computedStyle = getComputedStyle(o.sidebar);\n            o.marginBottom = parseFloat(computedStyle.marginBottom);\n            o.paddingTop = parseFloat(computedStyle.paddingTop);\n            o.paddingBottom = parseFloat(computedStyle.paddingBottom);\n\n            // Add a temporary padding rule to check for collapsable margins.\n            let collapsedTopHeight = getOffset(o.stickySidebar).top;\n            let collapsedBottomHeight = o.stickySidebar.offsetHeight;\n            o.stickySidebar.style.paddingTop = '1px';\n            o.stickySidebar.style.paddingBottom = '1px';\n            collapsedTopHeight -= getOffset(o.stickySidebar).top;\n            collapsedBottomHeight = o.stickySidebar.offsetHeight - collapsedBottomHeight - collapsedTopHeight;\n            if (collapsedTopHeight == 0) {\n                o.stickySidebar.style.paddingTop = '0px';\n                o.stickySidebarPaddingTop = 0;\n            } else {\n                o.stickySidebarPaddingTop = 1;\n            }\n\n            if (collapsedBottomHeight == 0) {\n                o.stickySidebar.style.paddingBottom = '0px';\n                o.stickySidebarPaddingBottom = 0;\n            } else {\n                o.stickySidebarPaddingBottom = 1;\n            }\n\n            // We use this to know whether the user is scrolling up or down.\n            o.previousScrollTop = 0;\n\n            // Scroll top (value) when the sidebar has fixed position.\n            o.fixedScrollTop = 0;\n\n            // Set sidebar to default values.\n            this.resetSidebar(o);\n\n            o.onScroll = () => {\n                // Stop if the sidebar isn't visible.\n                if (!this.isVisible(o.stickySidebar)) {\n                    return;\n                }\n\n                // Stop if the window is too small.\n                if (document.body.getBoundingClientRect().width < o.options.minWidth) {\n                    this.resetSidebar(o);\n                    return;\n                }\n\n                // Stop if the sidebar width is larger than the container width (e.g. the theme is responsive and the sidebar is now below the content)\n                if (o.options.disableOnResponsiveLayouts) {\n                    const sidebarWidth = getComputedStyle(o.sidebar).float === 'none' ? this.getOuterWidth(o.sidebar) : o.sidebar.offsetWidth;\n\n                    if (sidebarWidth + 50 > o.container.getBoundingClientRect().width) {\n                        this.resetSidebar(o);\n                        return;\n                    }\n                }\n\n                const scrollTop = window.scrollY;\n                let position = 'static';\n                const sidebarOffset = getOffset(o.sidebar);\n                let top = 0;\n\n                // If the user has scrolled down enough for the sidebar to be clipped at the top, then we can consider changing its position.\n                if (scrollTop >= sidebarOffset.top + (o.paddingTop - o.options.additionalMarginTop)) {\n                    // The top and bottom offsets, used in various calculations.\n                    const offsetTop = o.paddingTop + this.options.additionalMarginTop;\n                    const offsetBottom = o.paddingBottom + o.marginBottom + this.options.additionalMarginBottom;\n\n                    // All top and bottom positions are relative to the window, not to the parent elemnts.\n                    const containerTop = sidebarOffset.top;\n                    const containerBottom = getOffset(o.container).top + this.getClearedHeight(o.container);\n\n                    // The top and bottom offsets relative to the window screen top (zero) and bottom (window height).\n                    const windowOffsetTop = this.options.additionalMarginTop;\n                    let windowOffsetBottom;\n\n                    const sidebarSmallerThanWindow = (o.stickySidebar.offsetHeight + offsetTop + offsetBottom) < window.innerHeight;\n                    if (sidebarSmallerThanWindow) {\n                        windowOffsetBottom = windowOffsetTop + o.stickySidebar.offsetHeight;\n                    } else {\n                        windowOffsetBottom = window.innerHeight - o.marginBottom - o.paddingBottom - this.options.additionalMarginBottom;\n                    }\n\n                    const staticLimitTop = containerTop - scrollTop + o.paddingTop;\n                    const staticLimitBottom = containerBottom - scrollTop - o.paddingBottom - o.marginBottom;\n\n                    top = getOffset(o.stickySidebar).top - scrollTop;\n                    const scrollTopDiff = o.previousScrollTop - scrollTop;\n\n                    // If the sidebar position is fixed, then it won't move up or down by itself. So, we manually adjust the top coordinate.\n                    if (getComputedStyle(o.stickySidebar).position === 'fixed') {\n                        if (o.options.sidebarBehavior == 'modern') {\n                            top += scrollTopDiff;\n                        }\n                    }\n\n                    if (o.options.sidebarBehavior == 'stick-to-top') {\n                        top = this.options.additionalMarginTop;\n                    }\n\n                    if (o.options.sidebarBehavior == 'stick-to-bottom') {\n                        top = windowOffsetBottom - o.stickySidebar.offsetHeight;\n                    }\n\n                    if (scrollTopDiff > 0) { // If the user is scrolling up.\n                        top = Math.min(top, windowOffsetTop);\n                    } else { // If the user is scrolling down.\n                        top = Math.max(top, windowOffsetBottom - o.stickySidebar.offsetHeight);\n                    }\n\n                    top = Math.max(top, staticLimitTop);\n\n                    top = Math.min(top, staticLimitBottom - o.stickySidebar.offsetHeight);\n\n                    // If the sidebar is the same height as the container, we won't use fixed positioning.\n                    const sidebarSameHeightAsContainer = o.container.getBoundingClientRect().height == o.stickySidebar.offsetHeight;\n\n                    if (!sidebarSameHeightAsContainer && top == windowOffsetTop) {\n                        position = 'fixed';\n                    } else if (!sidebarSameHeightAsContainer && top == windowOffsetBottom - o.stickySidebar.offsetHeight) {\n                        position = 'fixed';\n                    } else if (scrollTop + top - sidebarOffset.top - o.paddingTop <= this.options.additionalMarginTop) {\n                        // Stuck to the top of the page. No special behavior.\n                        position = 'static';\n                    } else {\n                        // Stuck to the bottom of the page.\n                        position = 'absolute';\n                    }\n                }\n\n                /*\n                 * Performance notice: It's OK to set these CSS values at each resize/scroll, even if they don't change.\n                 * It's way slower to first check if the values have changed.\n                 */\n                if (position == 'fixed') {\n                    Object.assign(o.stickySidebar.style, {\n                        position: 'fixed',\n                        width: o.stickySidebar.getBoundingClientRect().width + 'px',\n                        transform: 'translateY(' + top + 'px)',\n                        left: (getOffset(o.sidebar).left + parseFloat(getComputedStyle(o.sidebar).paddingLeft) - window.scrollX) + 'px',\n                        top: '0px'\n                    });\n                } else if (position == 'absolute') {\n                    const css: Partial<CSSStyleDeclaration> = {};\n\n                    if (getComputedStyle(o.stickySidebar).position !== 'absolute') {\n                        css.position = 'absolute';\n                        css.transform = 'translateY(' + (scrollTop + top - sidebarOffset.top - o.stickySidebarPaddingTop - o.stickySidebarPaddingBottom) + 'px)';\n                        css.top = '0px';\n                    }\n\n                    css.width = o.stickySidebar.getBoundingClientRect().width + 'px';\n                    css.left = '';\n\n                    Object.assign(o.stickySidebar.style, css);\n                } else if (position == 'static') {\n                    this.resetSidebar(o);\n                }\n\n                if (position != 'static') {\n                    if (o.options.updateSidebarHeight) {\n                        o.sidebar.style.minHeight = (o.stickySidebar.offsetHeight + getOffset(o.stickySidebar).top - sidebarOffset.top + o.paddingBottom) + 'px';\n                    }\n                }\n\n                o.previousScrollTop = scrollTop;\n            };\n\n            // Initialize the sidebar's position.\n            o.onScroll();\n\n            // Recalculate the sidebar's position on every scroll and resize.\n            document.addEventListener('scroll', o.onScroll);\n            window.addEventListener('resize', o.onScroll);\n\n            // Recalculate the sidebar's position every time the sidebar changes its size.\n            o.resizeObserver = new ResizeObserver(() => {\n                o.onScroll();\n            });\n            o.resizeObserver.observe(o.stickySidebar);\n\n            this.stickySidebars.push(o);\n        });\n    }\n\n    private getOuterWidth(element: HTMLElement): number {\n        const style = getComputedStyle(element);\n\n        return element.getBoundingClientRect().width + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    }\n\n    private isVisible(element: HTMLElement) {\n        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n    }\n\n    // Reset the sidebar to its default state\n    private resetSidebar(s: StickySidebar) {\n        s.fixedScrollTop = 0;\n        s.sidebar.style.minHeight = '1px';\n        Object.assign(s.stickySidebar.style, {\n            'position': 'static',\n            'width': '',\n            'transform': 'none'\n        });\n    }\n\n    // Get the height of a div as if its floated children were cleared. Note that this function fails if the floats are more than one level deep.\n    private getClearedHeight(element: HTMLElement) {\n        let height = element.getBoundingClientRect().height;\n\n        Array.from(element.children).forEach(child => {\n            height = Math.max(height, child.getBoundingClientRect().height);\n        });\n\n        return height;\n    }\n}\n\nexport function getOffset(element: HTMLElement): { top: number, left: number } {\n    const rect = element.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY - document.documentElement.clientTop,\n        left: rect.left + window.scrollX - document.documentElement.clientLeft\n    };\n}\n"],"names":["TheiaStickySidebar","options","__publicField","o","finalOptions","element","javaScriptMIMETypes","script","computedStyle","collapsedTopHeight","getOffset","collapsedBottomHeight","scrollTop","position","sidebarOffset","top","offsetTop","offsetBottom","containerTop","containerBottom","windowOffsetTop","windowOffsetBottom","staticLimitTop","staticLimitBottom","scrollTopDiff","sidebarSameHeightAsContainer","css","style","s","height","child","rect"],"mappings":"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"}